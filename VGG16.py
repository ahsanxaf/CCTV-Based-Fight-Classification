# -*- coding: utf-8 -*-
"""VGG (1).ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1len-pdvEZASpAE6CfbAFto5JNiH-5rmf
"""

import tensorflow 
from tensorflow import keras
from tensorflow.keras.utils import to_categorical
from keras.applications.vgg19 import VGG19
from keras.models import Model
from tensorflow.keras import layers
from keras.preprocessing import image
from keras_preprocessing.image import ImageDataGenerator
from tensorflow.keras.layers import Input, Lambda ,Dense ,Flatten ,Dropout,GlobalAveragePooling2D,Dense,Flatten,Dropout,BatchNormalization,Conv2D,MaxPool2D
import numpy as np
import tensorflow  as tf
import os
import cv2 as cv

from google.colab import drive
drive.mount('/content/drive')

import zipfile
import os

zip_ref = zipfile.ZipFile('/content/drive/MyDrive/fight-detection-surv-dataset-master.zip', 'r') #Opens the zip file in read mode
zip_ref.extractall('/tmp') #Extracts the files into the /tmp folder
zip_ref.close()

directory = r'/tmp/fight-detection-surv-dataset-master'
CATEGORIES = ['fight', 'noFight']

data = []
labels = []
sample = []
for category in CATEGORIES:
    folder = os.path.join(directory, category)
    label = CATEGORIES.index(category)
    print(folder)
    for frame in os.listdir(folder):
        frm_path = os.path.join(folder, frame)
        cap = cv.VideoCapture(frm_path)
        while cap.isOpened():
            ret, frames = cap.read()
            if ret == True:
                #frames = cv.cvtColor(frames, cv.COLOR_BGR2GRAY)
                frames = cv.resize(frames, (224,224))
                data.append(frames)
                labels.append(category)
            else:
                break

image_shape = np.array(data[0]).shape
image_shape

data = np.array(data)
data.shape

from sklearn.model_selection import KFold

# Define the K-fold Cross Validator
kfold = KFold(n_splits=5, shuffle=True)

from sklearn import preprocessing

le = preprocessing.LabelEncoder()
le.fit(labels)
labels = le.transform(labels)

from keras.utils import np_utils
labels=np_utils.to_categorical(labels,2)

labels.shape

for train, test in kfold.split(data, labels):
  model=tf.keras.applications.vgg16.VGG16(
      include_top=True, weights=None, input_tensor=None,
      input_shape=(224,224,3), pooling=None, classes=2,)
  for layer in model.layers:
    layer.trainable = True
  classifier1 = model.output#head mode
  classifier1 = Flatten()(classifier1)#adding layer of flatten
  classifier1 = Dense(units=256, activation='relu')(classifier1)
  classifier1 = Dropout(0.6)(classifier1)
  classifier1 = Dense(units=2, activation='softmax')(classifier1)

model = Model(inputs = model.input , outputs = classifier1)
model.compile(optimizer='adam', loss='binary_crossentropy', metrics=['accuracy'])
#model.summary()
model.fit(data[train], labels[train], epochs = 5, validation_data = (data[test], labels[test]))

y_pred = model.predict(data[test], verbose=0)

from sklearn import preprocessing
le = preprocessing.LabelEncoder()
le.fit(y_pred)
y_pred = le.inverse_transform(y_pred)
print(y_pred)

from sklearn import metrics
y_pred=np.argmax(y_pred, axis=1)
y_test=np.argmax(labels[test], axis=1)
cm = metrics.confusion_matrix(y_test, y_pred)
print(y_pred)

Accuracy = metrics.accuracy_score(y_pred, y_test)

print(Accuracy)

recall_sensitivity = metrics.recall_score(y_test, y_pred, pos_label=0)
recall_specificity = metrics.recall_score(y_test, y_pred, pos_label=1)
print(recall_sensitivity, recall_specificity)







